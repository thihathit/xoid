/*! For license information please see 3e2466ef.25d1a576.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{68:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return p}));var o=n(2),a=n(6),r=(n(95),n(94)),s={id:"local-state",title:"Local component state"},c={unversionedId:"recipes/local-state",id:"recipes/local-state",isDocsHomePage:!1,title:"Local component state",description:"Unified way for local and global state management in React",source:"@site/../docs/recipes/local-state.md",slug:"/recipes/local-state",permalink:"/docs/recipes/local-state",editUrl:"https://github.com/onurkerimov/xoid/blob/master/website/../docs/recipes/local-state.md",version:"current",lastUpdatedAt:1633973670},l=[{value:"<code>useApp</code> (React) vs. <code>AppModel</code> (xoid)",id:"useapp-react-vs-appmodel-xoid",children:[]},{value:"Let&#39;s spice things up",id:"lets-spice-things-up",children:[]},{value:"Let&#39;s add even more stress!",id:"lets-add-even-more-stress",children:[{value:"Generalize common <code>useState</code> patterns",id:"generalize-common-usestate-patterns",children:[]}]}],i={rightToc:l};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},i,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"unified-way-for-local-and-global-state-management-in-react"},"Unified way for local and global state management in React"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"xoid")," is a scalable state management library with the aim of unifying global state and local component state in single API. This API has a small surface area and it's composed of low-level building blocks for creating advanced state management patterns. "),Object(r.b)("p",null,"In React world, separating logic and UI via custom hooks is already a common practice. However, xoid offers a further possibility. With xoid, you can separate component logic and UI in a truly ",Object(r.b)("strong",{parentName:"p"},"framework-agnostic")," manner."),Object(r.b)("p",null,"xoid is based on atomic stores. While ",Object(r.b)("inlineCode",{parentName:"p"},"useStore")," hook is used for consuming global ",Object(r.b)("strong",{parentName:"p"},"xoid")," stores, there's also the ",Object(r.b)("inlineCode",{parentName:"p"},"useLocal")," hook, which can be used to create stores on-the-fly, inside React components. These stores are kept around throughout a component's lifecycle, and can be cleaned up when the component is unmounted."),Object(r.b)("h2",{id:"useapp-react-vs-appmodel-xoid"},Object(r.b)("inlineCode",{parentName:"h2"},"useApp")," (React) vs. ",Object(r.b)("inlineCode",{parentName:"h2"},"AppModel")," (xoid)"),Object(r.b)("p",null,"To make a comparison between hooks and xoid models, let's consider the following custom React hook. It uses ",Object(r.b)("inlineCode",{parentName:"p"},"useState")," and ",Object(r.b)("inlineCode",{parentName:"p"},"useEffect")," hooks internally."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import { useState, useEffect } from 'react'\n\nconst useApp = () => {\n  const [alpha, setAlpha] = useState(3)\n  const [beta, setBeta] = useState(5)\n  const [sum, setSum] = useState(alpha + beta)\n  useEffect(() => setSum(alpha + beta), [alpha, beta])\n\n  return { alpha, beta, sum, setAlpha, setBeta }  \n}\n")),Object(r.b)("p",null,"Here's the equivalent ",Object(r.b)("strong",{parentName:"p"},"xoid")," model:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import { create } from 'xoid'\n\nconst AppModel = () => {\n  const alpha = create(3)\n  const beta = create(5)\n  const sum = create((get) => get(alpha) + get(beta))\n\n  return create({ alpha, beta, sum })\n}\n")),Object(r.b)("p",null,"Observe that the only import is ",Object(r.b)("inlineCode",{parentName:"p"},"create")," from xoid. ",Object(r.b)("inlineCode",{parentName:"p"},"create")," is the main building block of xoid, that's used for creating stores. Our function, ",Object(r.b)("inlineCode",{parentName:"p"},"AppModel")," is framework-agnostic. It means that it can easily be tested outside React, or perhaps it can be used inside another UI framework in the future. "),Object(r.b)("p",null,"Another advantage of xoid is that there's no need to expose ",Object(r.b)("inlineCode",{parentName:"p"},"setAlpha")," and ",Object(r.b)("inlineCode",{parentName:"p"},"setBeta")," like in the custom hook. We could have returned them, however we prefered not to. This can be advantageous especially for the cases where there are a lot of state portions to be read and written."),Object(r.b)("p",null,"Using ",Object(r.b)("inlineCode",{parentName:"p"},"useApp")," custom hook in a React component looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"export const App = (props) => {\n  const { alpha, beta, sum, setAlpha, setBeta } = useApp()\n  return (\n    <div>\n      {alpha}, \n      {beta}, \n      {sum}\n      <button onClick={() => setAlpha(alpha + 1)}>\n        increase alpha\n      </button>\n      <button onClick={() => setBeta(beta + 1)}>\n        increase beta\n      </button>\n    </div>\n  )\n}\n")),Object(r.b)("p",null,"whereas consuming ",Object(r.b)("inlineCode",{parentName:"p"},"AppModel")," model looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import { set, useLocal, useStore } from 'xoid'\n\nexport const App = (props) => {\n  const store = useLocal(AppModel)\n  const [{alpha, beta, sum}] = useStore(store)\n\n  return (\n    <div>\n      {alpha}, \n      {beta}, \n      {sum}\n      <button onClick={() => set(store.alpha, alpha + 1)}>\n        increase alpha\n      </button>\n      <button onClick={() => set(store.beta, beta + 1)}>\n        increase beta\n      </button>\n    </div>\n  )\n}\n")),Object(r.b)("p",null,"In xoid, ",Object(r.b)("inlineCode",{parentName:"p"},"useLocal")," and ",Object(r.b)("inlineCode",{parentName:"p"},"useStore")," hooks are usually used in tandem for local component state. ",Object(r.b)("inlineCode",{parentName:"p"},"useLocal")," creates a local value (once), and ",Object(r.b)("inlineCode",{parentName:"p"},"useStore")," subscribes the component to it.\nHowever, they need not to be used consecutively. One may prefer to create a local store in a parent component, and subscribe to that store in a child component. xoid is designed to provide the necessary flexibility for diverse requirements. Similarly, one can decide to consume a local store using a ",Object(r.b)("inlineCode",{parentName:"p"},"useEffect")," hook, without causing renders in the component."),Object(r.b)("h2",{id:"lets-spice-things-up"},"Let's spice things up"),Object(r.b)("p",null,"Now, to increase the difficulty of the stress test, let's assume that ",Object(r.b)("inlineCode",{parentName:"p"},"App")," is a controlled component, and we need to keep the state in sync with ",Object(r.b)("inlineCode",{parentName:"p"},"props.alpha")," and ",Object(r.b)("inlineCode",{parentName:"p"},"props.beta"),". So, usage of the hook should be changed to:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const { alpha, beta, sum, setAlpha, setBeta } = useCustomHook(props)\n")),Object(r.b)("p",null,"So, we need to modify our custom hook into the following:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import React, { useState, useEffect } from 'react'\n\nconst useCustomHook = (props: Props) => {\n  const [alpha, setAlpha] = useState(props.alpha)\n  useEffect(() => setAlpha(props.alpha), [props.alpha])\n\n  const [beta, setBeta] = useState(props.beta)\n  useEffect(() => setBeta(props.beta), [props.beta])\n\n  const [sum, setSum] = useState(alpha + beta)\n  useEffect(() => setSum(alpha + beta), [alpha, beta])\n\n  return { alpha, beta, sum, setAlpha, setBeta }  \n}\n")),Object(r.b)("p",null,"In our ",Object(r.b)("strong",{parentName:"p"},"xoid")," model on the other hand, we can achieve the same functionality by making ",Object(r.b)("inlineCode",{parentName:"p"},"alpha")," and ",Object(r.b)("inlineCode",{parentName:"p"},"beta")," into selectors."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import { create } from 'xoid'\n\nconst CustomModel = (deps: Store<Props>) => {\n  const sum = create((get) => get(deps.alpha) + get(.depsbeta))\n\n  return create({ alpha, beta, sum })\n}\n")),Object(r.b)("p",null,"A lot cleaner. No additional lines."),Object(r.b)("p",null,"To use it in a React component, simply add ",Object(r.b)("inlineCode",{parentName:"p"},"props")," as the second argument:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const store = useLocal(AppModel, props) // <== second arg added\nconst [{alpha, beta, sum}] = useStore(store)\n")),Object(r.b)("p",null,"Now, some details on what happened. We added a second argument to ",Object(r.b)("inlineCode",{parentName:"p"},"useLocal")," hook. When a value is provided in the second argument of ",Object(r.b)("inlineCode",{parentName:"p"},"useLocal")," hook, it's used to create a local store. Then, across renders, this store's value is kept in sync with the next values."),Object(r.b)("p",null,"Even with the addition of this second argument, our closure (",Object(r.b)("inlineCode",{parentName:"p"},"AppModel"),") still runs only once. ",Object(r.b)("inlineCode",{parentName:"p"},"useLocal")," hook, guarantees that the function in its first argument will run only once. "),Object(r.b)("p",null,"In ",Object(r.b)("inlineCode",{parentName:"p"},"AppModel"),", observe that we call it ",Object(r.b)("inlineCode",{parentName:"p"},"deps")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"props"),". Because ",Object(r.b)("inlineCode",{parentName:"p"},"deps")," is not ",Object(r.b)("inlineCode",{parentName:"p"},"props")," itself, it's actually a store in sync with ",Object(r.b)("inlineCode",{parentName:"p"},"props"),". Stores are reactive objects. This makes our closure (",Object(r.b)("inlineCode",{parentName:"p"},"AppModel"),") able to respond to changes in ",Object(r.b)("inlineCode",{parentName:"p"},"props"),", even though it's executed only once."),Object(r.b)("h2",{id:"lets-add-even-more-stress"},"Let's add even more stress!"),Object(r.b)("p",null,"Now, let's assume that we have another requirement. Let's also run some debounced ",Object(r.b)("inlineCode",{parentName:"p"},"props.onChange")," function when the values of ",Object(r.b)("inlineCode",{parentName:"p"},"alpha")," and ",Object(r.b)("inlineCode",{parentName:"p"},"beta")," is modified. Our custom React hook becomes even more complex when we try to meet this requirement. "),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import React, { useState, useEffect, useCallback } from 'react'\nimport { debounce } from \"lodash\";\n\nconst useCustomHook = (props) => {\n  const [alpha, setAlpha] = useState(3)\n  useEffect(() => setAlpha(props.alpha), [props.alpha])\n\n  const [beta, setBeta] = useState(5)\n  useEffect(() => setBeta(props.beta), [props.beta])\n\n  const [sum, setSum] = useState(alpha + beta)\n  useEffect(() => setSum(alpha + beta), [alpha, beta])\n\n  const debouncedOnChange = useCallback(\n    debounce(props.onChange, 500), \n    [props.onChange]\n  )\n  useEffect(() => debouncedOnChange(alpha, beta), [alpha, beta])\n\n  return { alpha, beta, sum, setAlpha, setBeta }  \n}\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"useCallback"),", an additional hook had to come to the scene."),Object(r.b)("p",null,"Meanwhile, in our xoid model, the changes are straightforward:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import { create, get } from 'xoid'\nimport { debounce } from \"lodash\";\n\nconst AppModel = (deps: Store<Props>) => {\n  const sum = create((get) => get(deps.alpha) + get(deps.beta))\n\n  const debouncedOnChange = debounce((a) => get(deps.onChange)(a), 500)\n  create((get) => debouncedOnChange(get(alpha), get(beta)))\n\n  return create({ alpha, beta, sum })\n}\n")),Object(r.b)("p",null,"Observe that in ",Object(r.b)("inlineCode",{parentName:"p"},"get(deps.onChange)")," part, we can use latest version of the ",Object(r.b)("inlineCode",{parentName:"p"},"props.onChange"),", without having to  use anything similar to ",Object(r.b)("inlineCode",{parentName:"p"},"useCallback"),", or without specifying the deps in a repetitive way. "),Object(r.b)("p",null,"Usage of React hooks for complex logic. brings other state caching related problems, especially in large components that there are too many state variables or props to keep track of as deps of ",Object(r.b)("inlineCode",{parentName:"p"},"useCallback"),", ",Object(r.b)("inlineCode",{parentName:"p"},"usEffect")," ",Object(r.b)("inlineCode",{parentName:"p"},"useMemo"),". "),Object(r.b)("p",null,"In react throttle, debounce, setInterval, setTimeout"),Object(r.b)("p",null,"In addition to all these, with xoid, you have the opportunity to"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"xoid")," gives a further possibility"),Object(r.b)("h3",{id:"generalize-common-usestate-patterns"},"Generalize common ",Object(r.b)("inlineCode",{parentName:"h3"},"useState")," patterns"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js",metastring:'title="./helpers.ts"',title:'"./helpers.ts"'}),"import { create } from 'xoid';\n\nexport const ToggleSetup = (payload: boolean = false) => {\n  const atom = create(payload)\n  return [atom, () => atom(s => !s)]\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js",metastring:'title="./Component.tsx"',title:'"./Component.tsx"'}),"import { BooleanModel } from './helpers';\nimport { useSetup, useAtom } from '@xoid/react';\n\nconst [$isModalOpen, toggleModal] = useSetup(ToggleSetup)\nconst isModalOpen = useAtom($isModalOpen)\n")))}p.isMDXComponent=!0},94:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return f}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=a.a.createContext({}),p=function(e){var t=a.a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=p(e.components);return a.a.createElement(i.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,i=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=o,f=u["".concat(s,".").concat(d)]||u[d]||b[d]||r;return n?a.a.createElement(f,c(c({ref:t},i),{},{components:n})):a.a.createElement(f,c({ref:t},i))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,s[1]=c;for(var i=2;i<r;i++)s[i]=n[i];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},95:function(e,t,n){"use strict";e.exports=n(96)},96:function(e,t,n){"use strict";var o=n(97),a="function"==typeof Symbol&&Symbol.for,r=a?Symbol.for("react.element"):60103,s=a?Symbol.for("react.portal"):60106,c=a?Symbol.for("react.fragment"):60107,l=a?Symbol.for("react.strict_mode"):60108,i=a?Symbol.for("react.profiler"):60114,p=a?Symbol.for("react.provider"):60109,u=a?Symbol.for("react.context"):60110,b=a?Symbol.for("react.forward_ref"):60112,d=a?Symbol.for("react.suspense"):60113,f=a?Symbol.for("react.memo"):60115,m=a?Symbol.for("react.lazy"):60116,h="function"==typeof Symbol&&Symbol.iterator;function O(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},y={};function j(e,t,n){this.props=e,this.context=t,this.refs=y,this.updater=n||g}function v(){}function C(e,t,n){this.props=e,this.context=t,this.refs=y,this.updater=n||g}j.prototype.isReactComponent={},j.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error(O(85));this.updater.enqueueSetState(this,e,t,"setState")},j.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},v.prototype=j.prototype;var w=C.prototype=new v;w.constructor=C,o(w,j.prototype),w.isPureReactComponent=!0;var N={current:null},k=Object.prototype.hasOwnProperty,S={key:!0,ref:!0,__self:!0,__source:!0};function x(e,t,n){var o,a={},s=null,c=null;if(null!=t)for(o in void 0!==t.ref&&(c=t.ref),void 0!==t.key&&(s=""+t.key),t)k.call(t,o)&&!S.hasOwnProperty(o)&&(a[o]=t[o]);var l=arguments.length-2;if(1===l)a.children=n;else if(1<l){for(var i=Array(l),p=0;p<l;p++)i[p]=arguments[p+2];a.children=i}if(e&&e.defaultProps)for(o in l=e.defaultProps)void 0===a[o]&&(a[o]=l[o]);return{$$typeof:r,type:e,key:s,ref:c,props:a,_owner:N.current}}function A(e){return"object"==typeof e&&null!==e&&e.$$typeof===r}var E=/\/+/g,P=[];function R(e,t,n,o){if(P.length){var a=P.pop();return a.result=e,a.keyPrefix=t,a.func=n,a.context=o,a.count=0,a}return{result:e,keyPrefix:t,func:n,context:o,count:0}}function _(e){e.result=null,e.keyPrefix=null,e.func=null,e.context=null,e.count=0,10>P.length&&P.push(e)}function M(e,t,n,o){var a=typeof e;"undefined"!==a&&"boolean"!==a||(e=null);var c=!1;if(null===e)c=!0;else switch(a){case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case r:case s:c=!0}}if(c)return n(o,e,""===t?"."+I(e,0):t),1;if(c=0,t=""===t?".":t+":",Array.isArray(e))for(var l=0;l<e.length;l++){var i=t+I(a=e[l],l);c+=M(a,i,n,o)}else if(null===e||"object"!=typeof e?i=null:i="function"==typeof(i=h&&e[h]||e["@@iterator"])?i:null,"function"==typeof i)for(e=i.call(e),l=0;!(a=e.next()).done;)c+=M(a=a.value,i=t+I(a,l++),n,o);else if("object"===a)throw n=""+e,Error(O(31,"[object Object]"===n?"object with keys {"+Object.keys(e).join(", ")+"}":n,""));return c}function $(e,t,n){return null==e?0:M(e,"",t,n)}function I(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+(""+e).replace(/[=:]/g,(function(e){return t[e]}))}(e.key):t.toString(36)}function T(e,t){e.func.call(e.context,t,e.count++)}function L(e,t,n){var o=e.result,a=e.keyPrefix;e=e.func.call(e.context,t,e.count++),Array.isArray(e)?B(e,o,n,(function(e){return e})):null!=e&&(A(e)&&(e=function(e,t){return{$$typeof:r,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(e,a+(!e.key||t&&t.key===e.key?"":(""+e.key).replace(E,"$&/")+"/")+n)),o.push(e))}function B(e,t,n,o,a){var r="";null!=n&&(r=(""+n).replace(E,"$&/")+"/"),$(e,L,t=R(t,r,o,a)),_(t)}var U={current:null};function D(){var e=U.current;if(null===e)throw Error(O(321));return e}var q={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:N,IsSomeRendererActing:{current:!1},assign:o};t.Children={map:function(e,t,n){if(null==e)return e;var o=[];return B(e,o,null,t,n),o},forEach:function(e,t,n){if(null==e)return e;$(e,T,t=R(null,null,t,n)),_(t)},count:function(e){return $(e,(function(){return null}),null)},toArray:function(e){var t=[];return B(e,t,null,(function(e){return e})),t},only:function(e){if(!A(e))throw Error(O(143));return e}},t.Component=j,t.Fragment=c,t.Profiler=i,t.PureComponent=C,t.StrictMode=l,t.Suspense=d,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=q,t.cloneElement=function(e,t,n){if(null==e)throw Error(O(267,e));var a=o({},e.props),s=e.key,c=e.ref,l=e._owner;if(null!=t){if(void 0!==t.ref&&(c=t.ref,l=N.current),void 0!==t.key&&(s=""+t.key),e.type&&e.type.defaultProps)var i=e.type.defaultProps;for(p in t)k.call(t,p)&&!S.hasOwnProperty(p)&&(a[p]=void 0===t[p]&&void 0!==i?i[p]:t[p])}var p=arguments.length-2;if(1===p)a.children=n;else if(1<p){i=Array(p);for(var u=0;u<p;u++)i[u]=arguments[u+2];a.children=i}return{$$typeof:r,type:e.type,key:s,ref:c,props:a,_owner:l}},t.createContext=function(e,t){return void 0===t&&(t=null),(e={$$typeof:u,_calculateChangedBits:t,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:p,_context:e},e.Consumer=e},t.createElement=x,t.createFactory=function(e){var t=x.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:b,render:e}},t.isValidElement=A,t.lazy=function(e){return{$$typeof:m,_ctor:e,_status:-1,_result:null}},t.memo=function(e,t){return{$$typeof:f,type:e,compare:void 0===t?null:t}},t.useCallback=function(e,t){return D().useCallback(e,t)},t.useContext=function(e,t){return D().useContext(e,t)},t.useDebugValue=function(){},t.useEffect=function(e,t){return D().useEffect(e,t)},t.useImperativeHandle=function(e,t,n){return D().useImperativeHandle(e,t,n)},t.useLayoutEffect=function(e,t){return D().useLayoutEffect(e,t)},t.useMemo=function(e,t){return D().useMemo(e,t)},t.useReducer=function(e,t,n){return D().useReducer(e,t,n)},t.useRef=function(e){return D().useRef(e)},t.useState=function(e){return D().useState(e)},t.version="16.13.1"},97:function(e,t,n){"use strict";var o=Object.getOwnPropertySymbols,a=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;function s(e){if(null==e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(t).map((function(e){return t[e]})).join(""))return!1;var o={};return"abcdefghijklmnopqrst".split("").forEach((function(e){o[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},o)).join("")}catch(a){return!1}}()?Object.assign:function(e,t){for(var n,c,l=s(e),i=1;i<arguments.length;i++){for(var p in n=Object(arguments[i]))a.call(n,p)&&(l[p]=n[p]);if(o){c=o(n);for(var u=0;u<c.length;u++)r.call(n,c[u])&&(l[c[u]]=n[c[u]])}}return l}}}]);